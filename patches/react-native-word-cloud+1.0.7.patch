diff --git a/node_modules/react-native-word-cloud/index.js b/node_modules/react-native-word-cloud/index.js
index c62bb41..662049e 100644
--- a/node_modules/react-native-word-cloud/index.js
+++ b/node_modules/react-native-word-cloud/index.js
@@ -13,8 +13,8 @@ class KeywordsCloud extends React.Component {
   handleCanvas = (canvas) => {
     const { keywords,scale, largestAtCenter, drawContainerCircle,containerCircleColor } = this.props;
     if (canvas) {
-      canvas.width = 300 
-      canvas.height = 300 
+      canvas.width = 400 //300 -> 400 
+      canvas.height = 400 //300 -> 400
       const center = { x: canvas.width / 2, y: canvas.height / 2 };
       const circles = generateCircles(
           keywords, center, scale, largestAtCenter);
@@ -25,7 +25,7 @@ class KeywordsCloud extends React.Component {
 
   render() {
     return (
-      <View style={{justifyContent:'center',alignItems:'center'}}>
+      <View style={{justifyContent:'center',alignItems:'center', backgroundColor : 'blue'}}>
         <Canvas ref={canvas => this.handleCanvas(canvas)} />
       </View>
     );
diff --git a/node_modules/react-native-word-cloud/utils.js b/node_modules/react-native-word-cloud/utils.js
index bb226c8..27a7402 100644
--- a/node_modules/react-native-word-cloud/utils.js
+++ b/node_modules/react-native-word-cloud/utils.js
@@ -25,7 +25,7 @@ return keywords.sort((a,b)=>a.frequency<b.frequency?-1:1)
 
 export const generateCircles = (keywordData, center, scale, largestAtCenter) => {
   const sortedKeywords = sortByFrequency(keywordData,largestAtCenter);
-  const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
+  /*const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
   const circles = sortedKeywords.map((keyword, index, arr) => ({
     center,
     size: (keyword.frequency / (sum)) * scale,
@@ -33,6 +33,26 @@ export const generateCircles = (keywordData, center, scale, largestAtCenter) =>
     label: keyword.keyword,
     ...spiralGenerator(index),
   }));
+  return circles;*/
+  const circles = sortedKeywords.map((keyword, index, arr) => {
+    // ðŸ‘‡ ê¸°ì¡´ ì½”ë“œ ì œê±°
+    // const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
+    // size: (keyword.frequency / (sum)) * scale,
+    
+    // ðŸ‘‡ ìƒˆë¡œìš´ ê³ ì • í¬ê¸° ë¡œì§
+    const baseRadius = 60; // ê°€ìž¥ í° ì›ì˜ ë°˜ì§€ë¦„
+    const radiusDecrement = 5; // 10pxì”© ê°ì†Œ
+    const radius = Math.max(baseRadius - (index * radiusDecrement), 20); // ìµœì†Œ 20px ë³´ìž¥
+    
+    return {
+      center,
+      size: radius, // ðŸ‘ˆ ê³ ì • í¬ê¸° ì‚¬ìš©
+      color: keyword.color,
+      label: keyword.keyword,
+      ...spiralGenerator(index),
+    };
+  });
+  
   return circles;
 };
 
@@ -54,6 +74,7 @@ const sortOnDistanceToCenter = (a, b) => {
 export const calcPositions = (circles) => {
   const sortedCircles = circles.sort(sortOnDistanceToCenter);
   const damping = 0.005;
+  const spacingFactor = 1.1; //ì¶”ê°€
   for (let pr = 0; pr < 5000; pr += 1) {
     // Push them away from each other
     for (let i = sortedCircles.length - 1; i >= 0; i -= 1) {
@@ -64,7 +85,7 @@ export const calcPositions = (circles) => {
         if (i !== j) {
           const dx = cj.x - ci.x;
           const dy = cj.y - ci.y;
-          const r = ci.size + cj.size;
+          const r = (ci.size + cj.size) * spacingFactor; // Adjusted for spacing
           const d = (dx * dx) + (dy * dy);
           if (d < (r * r) - 0.01) {
             const v = { x: dx, y: dy, z: 0 };
@@ -88,6 +109,34 @@ export const calcPositions = (circles) => {
       c.y -= vScaled.y;
     }
   }
+  // ðŸ‘‡ ê²½ê³„ ì¸¡ì • ì½”ë“œ ì¶”ê°€
+  if (circles.length > 0) {
+    let minX = Infinity, maxX = -Infinity;
+    let minY = Infinity, maxY = -Infinity;
+    
+    circles.forEach(circle => {
+      const leftEdge = circle.x - circle.size;
+      const rightEdge = circle.x + circle.size;
+      const topEdge = circle.y - circle.size;
+      const bottomEdge = circle.y + circle.size;
+      
+      minX = Math.min(minX, leftEdge);
+      maxX = Math.max(maxX, rightEdge);
+      minY = Math.min(minY, topEdge);
+      maxY = Math.max(maxY, bottomEdge);
+    });
+    
+    const boundingWidth = maxX - minX;
+    const boundingHeight = maxY - minY;
+    
+    console.log('=== ë²„ë¸” ì˜ì—­ ì¸¡ì • ===');
+    console.log(`ê²½ê³„ ë°•ìŠ¤: ${minX.toFixed(1)}, ${minY.toFixed(1)} â†’ ${maxX.toFixed(1)}, ${maxY.toFixed(1)}`);
+    console.log(`ì‹¤ì œ ì°¨ì§€ ì˜ì—­: ${boundingWidth.toFixed(1)} x ${boundingHeight.toFixed(1)}`);
+    console.log(`ìº”ë²„ìŠ¤ í¬ê¸°: 400 x 400`);
+    console.log(`ì—¬ìœ  ê³µê°„: ì¢Œì¸¡ ${minX.toFixed(1)}px, ìš°ì¸¡ ${(400-maxX).toFixed(1)}px`);
+    console.log(`ì—¬ìœ  ê³µê°„: ìƒë‹¨ ${minY.toFixed(1)}px, í•˜ë‹¨ ${(400-maxY).toFixed(1)}px`);
+    console.log('==================');
+  }
 };
 
 export const drawCirclesOnCanvas = (circles, canvas, drawContainerCircle, containerCircleColor) => {
@@ -108,7 +157,8 @@ export const drawCirclesOnCanvas = (circles, canvas, drawContainerCircle, contai
     ctx.fill();
     ctx.textAlign = 'center';
     ctx.textBaseline = 'middle';
-    ctx.font = `lighter ${Math.floor(circle.size / 4)}px sans-serif`;
+    //ctx.font = `lighter ${Math.floor(circle.size / 4)}px sans-serif`;
+    ctx.font = `18px Pretendard-SemiBold`;
     ctx.fillStyle = '#000000';
     ctx.fillText(circle.label, circle.x, circle.y);
   });
