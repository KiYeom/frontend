diff --git a/node_modules/react-native-word-cloud/index.js b/node_modules/react-native-word-cloud/index.js
index c62bb41..3fd51e4 100644
--- a/node_modules/react-native-word-cloud/index.js
+++ b/node_modules/react-native-word-cloud/index.js
@@ -13,9 +13,9 @@ class KeywordsCloud extends React.Component {
   handleCanvas = (canvas) => {
     const { keywords,scale, largestAtCenter, drawContainerCircle,containerCircleColor } = this.props;
     if (canvas) {
-      canvas.width = 300 
-      canvas.height = 300 
-      const center = { x: canvas.width / 2, y: canvas.height / 2 };
+      canvas.width = 350 //300 -> 400 
+      canvas.height = 400 //300 -> 400
+      const center = { x: canvas.width / 2, y: (canvas.height / 2)+20 };
       const circles = generateCircles(
           keywords, center, scale, largestAtCenter);
       calcPositions(circles);
diff --git a/node_modules/react-native-word-cloud/utils.js b/node_modules/react-native-word-cloud/utils.js
index bb226c8..e18a7da 100644
--- a/node_modules/react-native-word-cloud/utils.js
+++ b/node_modules/react-native-word-cloud/utils.js
@@ -25,7 +25,7 @@ return keywords.sort((a,b)=>a.frequency<b.frequency?-1:1)
 
 export const generateCircles = (keywordData, center, scale, largestAtCenter) => {
   const sortedKeywords = sortByFrequency(keywordData,largestAtCenter);
-  const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
+  /*const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
   const circles = sortedKeywords.map((keyword, index, arr) => ({
     center,
     size: (keyword.frequency / (sum)) * scale,
@@ -33,6 +33,26 @@ export const generateCircles = (keywordData, center, scale, largestAtCenter) =>
     label: keyword.keyword,
     ...spiralGenerator(index),
   }));
+  return circles;*/
+  const circles = sortedKeywords.map((keyword, index, arr) => {
+    // ðŸ‘‡ ê¸°ì¡´ ì½”ë“œ ì œê±°
+    // const sum = sortedKeywords.reduce((acc, current) => acc + current.frequency, 0);
+    // size: (keyword.frequency / (sum)) * scale,
+    
+    // ðŸ‘‡ ìƒˆë¡œìš´ ê³ ì • í¬ê¸° ë¡œì§
+    const baseRadius = 60; // ê°€ìž¥ í° ì›ì˜ ë°˜ì§€ë¦„
+    const radiusDecrement = 5; // 10pxì”© ê°ì†Œ
+    const radius = Math.max(baseRadius - (index * radiusDecrement), 20); // ìµœì†Œ 20px ë³´ìž¥
+    
+    return {
+      center,
+      size: radius, // ðŸ‘ˆ ê³ ì • í¬ê¸° ì‚¬ìš©
+      color: keyword.color,
+      label: keyword.keyword,
+      ...spiralGenerator(index),
+    };
+  });
+  
   return circles;
 };
 
@@ -54,6 +74,7 @@ const sortOnDistanceToCenter = (a, b) => {
 export const calcPositions = (circles) => {
   const sortedCircles = circles.sort(sortOnDistanceToCenter);
   const damping = 0.005;
+  const spacingFactor = 1.1; //ì¶”ê°€
   for (let pr = 0; pr < 5000; pr += 1) {
     // Push them away from each other
     for (let i = sortedCircles.length - 1; i >= 0; i -= 1) {
@@ -64,7 +85,7 @@ export const calcPositions = (circles) => {
         if (i !== j) {
           const dx = cj.x - ci.x;
           const dy = cj.y - ci.y;
-          const r = ci.size + cj.size;
+          const r = (ci.size + cj.size) * spacingFactor; // Adjusted for spacing
           const d = (dx * dx) + (dy * dy);
           if (d < (r * r) - 0.01) {
             const v = { x: dx, y: dy, z: 0 };
@@ -88,6 +109,7 @@ export const calcPositions = (circles) => {
       c.y -= vScaled.y;
     }
   }
+
 };
 
 export const drawCirclesOnCanvas = (circles, canvas, drawContainerCircle, containerCircleColor) => {
@@ -108,7 +130,8 @@ export const drawCirclesOnCanvas = (circles, canvas, drawContainerCircle, contai
     ctx.fill();
     ctx.textAlign = 'center';
     ctx.textBaseline = 'middle';
-    ctx.font = `lighter ${Math.floor(circle.size / 4)}px sans-serif`;
+    //ctx.font = `lighter ${Math.floor(circle.size / 4)}px sans-serif`;
+    ctx.font = `18px Kyobo-handwriting`;
     ctx.fillStyle = '#000000';
     ctx.fillText(circle.label, circle.x, circle.y);
   });
